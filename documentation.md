# Интерпретируемый язык программирования Flopper
Интерпретатор языка написан на языке программирования _F#_

## Авторы

|       Имя       |                  Роль в проекте                  |
|:---------------:|:------------------------------------------------:|
| Ахметшин Булат  |               Разработчик парсера                |
| Теребаев Кирилл | Разработчик интерпретатора, технический писатель |
| Шипилов Кирилл  |   Разработчик интерпретатора, обработка ошибок   |

## Реализованные возможности
В языке реализованы:
- Типизация. Реализованные типы:
  - `real` (целое число или число с плавающей точкой);
  - `string` (строка);
  - `bool` (логическое значение);
- Операторы:
  - Арифметические операторы (`+, -, *, /, //`);
  - Логические операторы (`&, /)`;
  - Операторы сравнения (`>, >=, <, <=, ==, !=`);
- Функции;
- Встроенные функции:
  - `read_real()` - возвращает значение real, полученное из потока ввода;
  - `read_string()` - возвращает значение string, полученное из потока ввода;
  - `print(\<expr_1\>, ..., \<expr_n\>)` - отправляет в поток вывода результаты
    введенных выражений
- Рекурсивный вызов функций;
- Замыкание;
- Обработка ошибок (валидация названий переменных, валидация ввода).

## Примеры

### Объявление переменных
```
real a = 5;
real b = 10.5;
real c = read_real();
string d = "something";
string e = read_string();
bool f = true;
```
### Объявление функций
```
func increment = lambda (real n) {
    n + 1
};
```
### Пример факториала
```
func factorial = lambda (real n) {
    if (n == 0 | n == 1) {
        1
    } else {
        n * factorial(n - 1)
    }
};

real n = read_real();
print(factorial(n - 1), factorial(n), factorial(n + 1))
```
### Пример счетчика с использованием замыкания
```
func f = lambda (real n) {
    func g = lambda () {
        print(n);
        f(n + 1)
    }
};

func cnt = f(0);
func cnt = cnt();
func cnt = cnt()
```

## Описание интерпретатора
Интерпретация происходит в два этапа:
- Преобразование кода в набор токенов. В нашем проекте для этого используется библиотека
  FParsec. Реализацию парсера можно увидеть в файле `Parser.fs`.
- Для выполнения мы реализовали абстрактный класс Tokens с методом Eval и
  имплементировали метод для всех дочерних классов. Для хранения переменных
  мы использовали `Map<string, Value>`. Сами реализации токенов и метода Eval для них можно увидеть в директории `Tokens`.

Запуск самого интерпретатора происходит из файла `Program.fs`.
